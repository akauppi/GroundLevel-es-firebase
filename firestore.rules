rules_version = '2';

// Note: When editing the rules, consider using the online Rules Simulator:
//      e.g. https://console.firebase.google.com/u/0/project/vue-rollup-example/database/firestore/rules
//
service cloud.firestore {
  match /databases/{database}/documents {

    match /projects/{projectId} {
      // Read
      //    - authors can see all projects, also removed (archived)
      //    - collaborators see only active projects
      //
      // Note: Checking for validity at reads is optional. There is no added cost to doing so, however (our validation
      //        rule does not reference other documents), and doing validation guards against bad data caused by
      //        manual changes, admin SDK changes, or data written by earlier generations of the security rules.
      //
      allow read: if (isAuthor() || isCollaborator() && !isRemoved())
        //&& validProject()       // optional: enable if you want to guard against bad data instead of letting client cope with it
            // ^-- tbd. enable. Currently causes 2 tests to fail

      // Creation
      //    - the creating user must list themselves as an author
      //    - creating time-stamp must be a 'FieldValue.serverTimestamp()'
      //    - may not be created as 'removed'
      //
      allow create: if isSignedIn()
        && validProject()
        && request.resource.data.created == request.time
        && !isRemovedAfter()
        && request.auth.uid in request.resource.data.authors    // creator added as an author (we could go soft on this..)

      // Update
      //    | field    | mutability |
      //    |----------|------------|
      //    | /title   | author may change |
      //    | /created | no |
      //    | /removed | author may add or remove; no other fields may change; if added, must be the server timestamp |
      //    | /authors | author may change; at least one author must remain |
      //    | /collaborators | author may change |
      //
      allow update: if isAuthor()
        && validProject()
        && (request.resource.data.created == resource.data.created)
        && ((
          onlyRemovedAdded() && request.resource.data.removed == request.time
        ) || (
          onlyRemovedRemoved() && true
        ) || (
          removedUnaffected() && true
        ))

      function onlyRemovedAdded() {
        return _onlyRemovedAffected() && isRemovedAfter()
      }
      function onlyRemovedRemoved() {
        return _onlyRemovedAffected() && !isRemovedAfter()
      }
      function _onlyRemovedAffected() {
        return request.resource.data.diff(resource.data).affectedKeys() == ["removed"].toSet()
      }

      function removedUnaffected() {
        // Implementation note: if not using '.diff', you must consider the case when there is no '.removed' (it's optional).
        return !("removed" in request.resource.data.diff(resource.data).affectedKeys())
      }

      allow delete: if false        // no deletion via web app

      // Project consistency:
      //  - title may not be empty
      //  - created must exist
      //  - removed is optional; if exists, must be a server time stamp now or in the past
      //  - at least one author must exist
      //  - collaborators can be empty
      //  - users are either in 'authors' or in 'collaborators' (but not in both)
      //
      // Note: To allow reads to use the consistency, it is important to mark server time stamp fields as '<='
      //        instead of '='.
      //
      function validProject() {
        let possibleKeys = ["title", "created", "removed", "authors", "collaborators"].toSet();

        return true
          && request.resource.data.title is string && request.resource.data.title != ''
          && request.resource.data.created is timestamp
          && (!isRemovedAfter() || (request.resource.data.removed <= request.time))
          && request.resource.data.authors is list && request.resource.data.authors.size() > 0
          && request.resource.data.collaborators is list
          && request.resource.data.authors.toSet().intersection( request.resource.data.collaborators.toSet() ).size() == 0
            // no common entries (could also omit this; logic would work even if a user is listed in both)

          && possibleKeys.hasAll( request.resource.data.keys() )        // no unexpected keys
      }

      function isAuthor() {
        return isSignedIn() &&
          request.auth.uid in resource.data.authors
      }

      function isCollaborator() {
        return isSignedIn() &&
          request.auth.uid in resource.data.collaborators
      }

      function isCollaboratorOrAuthor() {
        return isSignedIn() &&
          (isCollaborator() || isAuthor())
      }

      function isRemoved() {
        return "removed" in resource.data
      }

      function isRemovedAfter() {
        return "removed" in request.resource.data
      }

//--- Visited ---

      match /visited/{userId} {
        // Read:
        //	- all project members can read each other's last visit time
        //
        allow read: if EXT_isCollaboratorOrAuthor()

        // Write:
        //	- only the user themselves can reset their value
        //
        // Note: requiring the 'after' value to be the server time stamp essentially disallows deletes.
        //
        allow write: if EXT_isCollaboratorOrAuthor()   // Q: can this reach the parent document, even without 'get'?
          && validVisited()
          && userId == request.auth.uid
          && request.resource.data.at == request.time

        // Visited consistency:
        //  - 'at' must be a timestamp
        //  - no other fields
        //
        function validVisited() {
          return true
            && (request.resource.data.at is timestamp && request.resource.data.at <= request.time)
            && request.resource.data.keys() == ['at']     // no other fields
        }
      }

//--- Symbols ---

      match /symbols/{symbolId} {
        // Read:
        //  - all members of the project can read
        //
        allow read: if EXT_isCollaboratorOrAuthor();        // anyone (within the project) can read

        // Creation:
        //	- the creator needs to claim the symbol to themselves, at creation (we can relax this, if needed)
        //
        allow create: if EXT_isCollaboratorOrAuthor()
          && validSymbol()
          && isClaimedByMe()
          && request.resource.data.claimed.at == request.time

        // Updates:
        //  - can claim a non-claimed symbol
        //  - can do changes to an already claimed symbol
        //  - can revoke the claim
        //  - claim itself cannot be changed; only revoked
        //
        allow update: if EXT_isCollaboratorOrAuthor()
          && validSymbol()
          && ((     // case A: claiming an unclaimed symbol
            !isClaimed() && (
              request.resource.data.claimed.by == request.auth.uid &&		// I make the claim
              request.resource.data.claimed.at == request.time
            )
          ) || (    // case B: revoking the claim
            isClaimedByMe() && (
              !("claimed" in request.resource.data)     // claim removed
            )
          ))

        // Delete:
        //	- can delete a symbol claimed to themselves
        //
        allow delete: if EXT_isCollaboratorOrAuthor()
          && isClaimedByMe()

        function validSymbol() {
          let requiredKeys = ['layer','shape','size','fillColor','center'].toSet();
          let possibleKeys = requiredKeys.union( ['claimed'].toSet() );

          return true
            && (request.resource.data.keys().toSet().hasAll(requiredKeys) &&
              possibleKeys.hasAll(request.resource.data.keys()))
            && request.resource.data.layer is int
            && request.resource.data.shape in ['star']      // enum
            && request.resource.data.size > 0
            && request.resource.data.fillColor is string
            && (request.resource.data.center.keys() == ["x","y"] &&
               request.resource.data.center.x is number &&
               request.resource.data.center.y is number
            )
            && (!isClaimed() || ("claimed" in request.resource.data &&
              request.resource.data.claimed.keys() == ["by","at"] &&   // only these
              request.resource.data.claimed.by is string &&
              request.resource.data.claimed.at is timestamp     // and <= request.time
            ))
        }

        function isClaimedByMe() {
          return isClaimed() && resource.data.claimed.by == request.auth.uid
        }

        function isClaimed() {
          // Note: 'resource != null' required in the online Rules Playground
          return resource != null && "claimed" in resource.data
        }
      } // symbols

      // Functions for sub-collections
      //
      // While the 'project' documents can address their 'authors' and 'collaborators' fields directly, sub-collection
      // documents must use 'get'. This also implies an added billing cost for processing those security rules!

      function EXT_isCollaboratorOrAuthor() {
        return isSignedIn() &&
          (request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.collaborators ||
           request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.authors
          )
      }
    }   // project

//--- Invites ---
//
// Writable by authors and collaborators, to invite new members to the project. From there, Cloud Functions should
// do all.

    match /invites/{inviteId} {   // inviteId: '<email>_<projectId>'
      // Read:
      //  - only Cloud Functions read invites
      allow read: if false

      // Create:
      //  - any collaborator or author of a project may invite more people
      //  - a previous invite may be overwritten (hmm.. tbd. does that fall onto 'update' or does 'set' always bring here?)
      //
      allow create: if GLOBAL_isCollaboratorOrAuthor(request.resource.data.project) &&
        validInvite()

      allow update, delete: if false
    }

    function validInvite() {
      let requiredKeys = ['invitedEmail','project','by','at'].toSet();

      return true
        && request.resource.data.keys().toSet() == requiredKeys
        && request.resource.id == request.resource.data.invitedEmail +"_"+ request.resource.data.project	// validate also the id schema
        && request.resource.data.invitedEmail is string
        && request.resource.data.project is string
        && request.resource.data.by == request.auth.uid
        && request.resource.data.at == request.time
    }

//--- User info ---
//
// Fully handled via Cloud Functions

    match /userInfo/{userId} {
      allow read, write: if false
    }

//--- Authentication (just functions) ---

    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    // Checking membership in a project from other collections.
    //
    // This variant is to be used for collections outside of the 'projectsC'.
    //
    function GLOBAL_isCollaboratorOrAuthor(projectId) {
      return isSignedIn() &&
        (request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.collaborators ||
         request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.authors
        )
    }

  } // database
}
