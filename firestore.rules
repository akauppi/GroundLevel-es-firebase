rules_version = '2';

// Note: When editing the rules, consider using the online Rules Simulator
//      -> https://console.firebase.google.com/project/ ... /database/firestore/rules
//
//      It gives good error messages and has syntax highlighting.
//
service cloud.firestore {
  match /databases/{database}/documents {

    match /projects/{projectId} {
      // Read
      //    - allows also removed (archived) projects to be seen
      //
      allow read: if isCollaboratorOrAuthor()

      // Creation
      //    - the creating user must list themselves as an author
      //    - creating time-stamp must be done using 'FieldValue.serverTimestamp()'
      //
      allow create: if isSignedIn()
        && validProject()
        && request.resource.data.created == request.time
        && request.resource.data.removed == null
        && request.auth.uid in request.resource.data.authors    // creator added as an author (we could go soft on this..)

      // Update
      //    - must not be changed:              /created
      //    - required to be author to change:  /title, /authors, /collaborators, /removed
      //
      allow update: if isAuthor()
        && validProject()
        && resource.data.removed == null
        && request.resource.data.created == resource.data.created
        && (request.resource.data.removed == null || request.resource.data.removed == request.time)     // if given, must be current server time

      allow delete: if false        // no deletion via web app

      // Project consistency:
      //  - title may not be empty
      //  - created must exist
      //  - at least one author must remain
      //  - users are either in 'authors' or in 'collaborators' (but not both)
      //
      function validProject() {
          return true
              && request.resource.data.title is string && request.resource.data.title != ''
              && request.resource.data.created is timestamp
              && (request.resource.data.removed == null || request.resource.data.removed is timestamp)
              && request.resource.data.authors is list && request.resource.data.authors.size() > 0
              && request.resource.data.collaborators is list
              && (!request.resource.data.authors.hasAny( request.resource.data.collaborators ))     // note: could skip this (duplicates wouldn't hurt the logic)
              && (!request.resource.data.collaborators.hasAny( request.resource.data.authors ))     //      -''-
      }

      function isAuthor() {
        return isSignedIn() &&
          request.auth.uid in resource.data.authors
      }

      function isCollaborator() {
        return isSignedIn() &&
          request.auth.uid in resource.data.collaborators
      }

      function isCollaboratorOrAuthor() {
        return isSignedIn() &&
          (isCollaborator() || isAuthor())
      }

      //--- Users ---

      match /users/{userId} {
        allow read: if isCollaboratorOrAuthor();        // anyone (within the project) can list and get

        allow create: if isAuthorAfter()       // anyone who's author after the request would pass (i.e. allows first time creation, adding the user as an author)
          && validUser()
          && request.resource.data.lastOpened == null       // does not exist, until the user visits
          && request.resource.data.pendingInvite == request.time        // pending since now (in server time)

        allow update: if !isMyUserEntry() && isAuthor()       // other person's user entry
          && validUser()
          && request.resource.data.lastOpened == request.data.lastOpened        // only user themselves may change
          && request.resource.data.pendingInvite == request.data.pendingInvite  // only user themselves may change

        allow update: if isMyUserEntry()        // one's own user entry
          && validUser()
          && request.resource.data.role == resource.data.role       // don't allow even an author to downgrade themselves to collaborator (ensures indirectly that at least one author remains)
          && request.resource.data.lastOpened == resource.time      // updating only to server time allowed (and expected)
          && request.resource.data.pendingInvite == null            // removal of '.pendingInvite' required

        allow delete: if false      // tbd. we maybe should allow deletion of users, by someone who remains an author?

        function isMyUserEntry() {
            return isSignedIn() && request.auth.uid == userId
        }

        function validUser() {
            return true
                && request.resource.data.role in ['author', 'collaborator']     // must be either
                && (    // either of them
                    (request.resource.data.lastOpened && request.resource.data.lastOpened is timestamp) ||
                    (request.resource.data.pendingInvite && request.resource.data.pendingInvite is timestamp)
                )
        }
      }

      //--- Symbols ---

      match /symbols/{symbolId} {
        allow read: if isCollaboratorOrAuthor();        // anyone (within the project) can read

        allow create: if isCollaboratorOrAuthor()
            && validSymbol()
            && request.resource.data.claimedBy == request.auth.uid
            && request.resource.data.claimedAt == request.time

        // Updates only allowed to shapes claimed by oneself. Claim itself cannot be changed; only cleared.
        //
        allow update: if isCollaboratorOrAuthor()
            && validSymbol()
            && claimedByMe()
            && (request.resource.data.claimedBy == null || (
                request.resource.data.claimedBy == resource.data.claimedBy &&
                request.resource.data.claimedAt == resource.data.claimedAt
            ))

        allow delete: if isCollaboratorOrAuthor()
            && claimedByMe()

        function claimedByMe() {
            return claimedBy() == request.auth.uid
        }

        function claimedBy() {
            return resource.data.claimedBy      // before the change
        }

        function validSymbol() {
          let requiredKeys = ['layer','shape','size','fillColor','center'].toSet();
					let possibleKeys = requiredKeys.union( ['claimedBy', 'claimedAt'].toSet() );

          return true
              && (request.resource.data.keys().toSet().hasAll(requiredKeys) && possibleKeys.hasAll(request.resource.data.keys()))
              && (request.resource.data.claimedBy == null || request.resource.data.claimedBy is string)
              && (request.resource.data.claimedAt == null || request.resource.data.claimedAt is timestamp)
              && bothOrNeither(request.resource.data.claimedBy, request.resource.data.claimedAt)
              && request.resource.data.layer is int
              && request.resource.data.shape in ['star']      // enum
              && request.resource.data.size > 0
              && request.resource.data.fillColor is string
              && request.resource.data.center.x is number
              && request.resource.data.center.y is number
        }

        function bothOrNeither(a,b) {
          return ((a == null && b == null) || (a && b))
        }

        //REMOVE?
        //function isAuthor() {
        //  return isSignedIn() &&
        //    request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.authors
        //}
        //
        //function isCollaborator() {
        //  return isSignedIn() &&
        //    request.auth.uid in get( /databases/$(database)/documents/projects/$(projectId) ).data.collaborators
        //}
        //
        //function isCollaboratorOrAuthor() {
        //  return isSignedIn() &&
        //    (isCollaborator() || isAuthor())
        //}
      }   // symbols


      //--- Authentication ---

      function isSignedIn() {
        return request.auth != null && request.auth.uid != null;
      }
    }  // project
  } // database
}

