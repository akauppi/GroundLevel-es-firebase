# Firebase tips


## Use creation date in the project id

Firebase automatically appends a uniqueness id to your project id (e.g. `mysome-5342`). You can edit this to your liking, and using `DDMMYY` format may provide extra benefit to a random number:

- you know when you created it (how stale it is)
- if you end up creating multiple projects for the same thing, it helps keep log

While you *can* likely get this info from elsewhere, why not just make randomness work for you. :)


## Firestore: use array/object or a collection?

Firestore works on the document-collection-document-... pattern (see [Cloud Firestore Data model](https://firebase.google.com/docs/firestore/data-model) (Firebase docs)).

One can express a dataset either within a document, or as a combination of documents and subcollections. Here are the pros/cons of both approaches:

### Within a document

Pros:

- Simple, traditional
- May be cheaper: access is charged by documents read, and access to multiple fields of a single document counts as 1 read. This may be the strongest reason to avoid splitting data to sub-collections.

Cons:

- Not native thinking for Firebase
- Access is all-or-nothing

### As sub-collections

Essentially the inverse of the pros/cons above. :)


### Quotes

>Don't add subcollections unless you need it. I only add them when there is a large amount of related data that does not need to be pulled Everytime I retrieve root data.<sub>[source](https://www.reddit.com/r/Firebase/comments/bi45dr/firestore_is_there_any_good_reason_to_use/)</sub>

Ability to do [Collection group queries](https://firebase.google.com/docs/firestore/query-data/queries#collection-group-query) (Firebase docs) has likely evened the weigh for using sub-collections (they were launched in 2019). If you read online, consider any experiences *prior* to that as potentially misleading. 🍄


## Syntax highlighting of Security Rules on IntelliJ IDEs (kind of...)

See [this answer](https://stackoverflow.com/questions/46600491/what-is-the-name-of-the-language-used-for-cloud-firestore-security-rules/60848863#60848863) (StackOverflow) about setting up "file type associations" in IntelliJ IDEA - may also work in WebStorm.

In addition, set to 2 spaces:


## Understanding `firebase use`

It defines which Firebase project your development terminal and local instance started by, say, `npm run dev`, is connected to.

|||
|---|---|
|List the current shortcuts|`firebase use`|
|Make a new shortcut|`firebase use --add`|

The aliases you give don't really matter. `abc` is a good candidate. ;P

```
$ more .firebaserc 
{
  "projects": {
    "default": "vue-rollup-example",
    "prod": "groundlevel-production"
  }
}
```


## Security Rules Online Simulator

The simulator can be very useful, providing detailed information on why a certain rule failed. But you need to know where to look.

>Note: Now that Firebase is bringing the development experience more towards the local (with emulation), how about a local tool for this use case so we don't need to copy-paste rules files to the cloud? (27-Aug-20)

### Rule, Evaluated

Scroll to the top right of the window. Here you see how Firebase evaluates your rule:

![](.images/rule-evaluated.png)

You can click each rule fragment open to see what it evaluates to. Any surprises lead you further.


### Entering `FieldValue` values

There is no UI support for building a document with `FieldValue`s (e.g. server time stamp) but maybe we can fool the simulator by:

```
{
  _methodName: 'FieldValue.serverTimestamp'
}
```



## Viewing logs online

Easiest to get to the online logs:

```
$ firebase functions:log --only logs_v200719 --open
```

Click `Preview`.

![](.images/logs-viewer-preview.png)

Nice! 😀

See filtering info -> [Logs Based Metrics](https://firebase.google.com/docs/functions/writing-and-viewing-logs#logs-based_metrics) (Firebase docs)

Note that Firebase logs are intended for the back end (which is always online). The front end library has no means for central logging.


## You can `debug()` security rules!

Firebase Rules Reference > [rules.debug](https://firebase.google.com/docs/reference/rules/rules.debug) (Firebase docs)

>Note that the output goes to `firestore-debug.log`, not stdout.


## Debugging Security Rules tests

The `firestore-debug.log` file generated by the emulator may provide info about why some rules work different than intended:

```
...
INFO: operation failed: 
Function not found error: Name: [validUserInfoWrite]. for 'create' @ L334
...
```


## Changes are different in server triggers vs. Firestore client

Listening to changes to a document, using Cloud Firestore triggers (`firestore-functions`):

```
exports.blah = regionalFunctions.firestore
  .document('/userInfo/{uid}')
  .onWrite( async (change, context) => {
    // no change types
    // change.before: QueryDocumentSnapshot 
    // change.after: -''-
    //
    const uid = change.after.id;   // document id
```


Doing the same in client code (`firebase`):

```
db.collection("userInfo/{uid}")
  .onSnapshot( snapshot => {
    snapshot.docChanges().forEach( change => {
      // change.type: "added"|"modified"|...
      // change.doc.data(): 
```


||Cloud Functions trigger (server)|Firestore client|
|---|---|---|
|Change type|implied by one's choice of listener method: `.onCreate`,`.onUpdate`,`.onWrite`,`.onDelete`|change indicated by `change.type` (enum: "added"\|"modified"\|"removed")|
|Document id|`change.after.id`|...|
|Previous contents|`change.before.data()`|n/a|
|New contents|`change.after.data()`|`change.doc.data()`|

These are essentially two wholly separate APIs and there are likely reasons why they are so. The first happens **on demand** at the server, whereas the client approach is an ongoing watcher for data changes.

References:

- [Cloud Firestore function triggers](https://firebase.google.com/docs/functions/firestore-events#function_triggers) (Firebase docs)
- [View changes between snapshots](https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots) (Firebase docs)

